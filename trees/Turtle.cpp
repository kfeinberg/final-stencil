#include "Turtle.h"

Turtle::Turtle()
{
    resetTurtle();
}

/**
 * @brief The LSystem class
 *
 * Symbolic explanations:
 * F move forward by d units
 * + yaw left by angle δ
 * - yaw right by angle δ
 * & pitch down by angle δ
 * ∧ pitch up by angle δ
 * \ roll left by angle δ
 * / roll right by angle δ
 * [ start of new branch (push the state onto the stack)
 * ] end of branch (pop the state from the stack and old state becomes current state)
 * > : decrease thickness (by percent of its own)
 * < : increase thickness (by percent of its own)
 * = : set thickness (to percentage of length)
 * * : draw leaf
 */ 
void Turtle::resetTurtle() {
    m_pos = glm::vec3(0.0f, 0.0f, 0.0f);
    m_thickness = f_dist * length_thickness_ratio;
    m_dir = glm::vec3(0.0f, 1.0f, 0.0f);
    m_right = glm::vec3(1.0f, 0.0f, 0.0f);
    m_cylinderTransformations.clear();
    m_treeComponents.clear();
}

/**
 * @brief Iterates through string and performs actions.
 * @param input string generated by L-system.
 */
void Turtle::parseInput(std::string input, glm::mat4x4 trans) {
    resetTurtle();
    m_sceneTrans = trans;

    std::string::size_type i = 0;
    std::string::size_type inputSize = input.size();
    while (i < inputSize) {
        char command = input[i];
        // case where command has argument
        if ((i + 3) < inputSize && input[i+1]=='(') {
            executeCommand(command, true, static_cast<float>(input[i+2]));
            i += 4;
        }
        else {
            executeCommand(command, false, 0);
            i += 1;
        }
    }
}

void Turtle::executeCommand(char command, bool hasParam, float param) {
    switch(command) {
        case 'F':
            moveForward();
            break;
        case '+':
            if (hasParam) yawRight(param * M_PI/180.0f);
            else yawRight(theta * M_PI/180.0f);
            break;
        case '-':
            if (hasParam) yawRight(-(param * M_PI/180.0f));
            else yawRight(-(theta * M_PI/180.0f));
            break;
        case '&':
            if (hasParam) pitchUp(param * M_PI/180.0f);
            else pitchUp(theta * M_PI/180.0f);
            break;
        case '^':
            if (hasParam) pitchUp(-(param * M_PI/180.0f));
            else pitchUp(-(theta * M_PI/180.0f));
            break;
        case '\\':
            if (hasParam) rollRight(param * M_PI/180.0f);
            else rollRight(theta * M_PI/180.0f);
            break;
        case '/':
            if (hasParam) rollRight(-(param * M_PI/180.0f));
            else rollRight(-(theta * M_PI/180.0f));
            break;
        case '[':
            this->save();
            break;
        case ']':
            this->restore();
            break;
        case '>':
            if (hasParam) m_thickness *= 1-(param/100);
            m_thickness *= 1-(thickness_mult/100);
            break;
        case '<':
            if (hasParam) m_thickness *= 1+(param/100);
            m_thickness *= 1+(thickness_mult/100);
            break;
//        case '=': // TODO: not implemented yet
//            m_thickness = param/100;
//            break;
        case '*':
            drawLeaf();
            break;
        case '|':
            m_dir = -m_dir;
            m_right = -m_right;
    }
}

/**
 * @brief Save cylinder position and move turtle forward.
 */
void Turtle::moveForward() {

    // update position vector with forward step
    m_pos = m_pos + f_dist/2.0f * m_dir; // move forward f-dist/2

    m_cylinderTransformations.push_back(currTransMatrix());
    m_treeComponents.push_back(TreeComponents::BRANCH);

    m_pos = m_pos + f_dist/2.0f * m_dir; // move forward f-dist/2
}

/**
 * @brief Draws leaf at current turtle location.
 */
void Turtle::drawLeaf() {
    glm::mat4x4 scale = glm::scale(glm::vec3(leaf_size, leaf_size, 1)); // makes leaf small

    glm::vec3 orig = glm::vec3(0, 1, 0);
    float theta = acos(glm::dot(orig, m_dir)) + leaf_angle;
    glm::mat4x4 rotate = glm::rotate(theta, glm::normalize(glm::cross(orig, m_dir)));

    glm::mat4 trans = m_sceneTrans * glm::translate(glm::vec3(m_pos.x, m_pos.y, m_pos.z)); // translates cylinder to current turtle

    m_cylinderTransformations.push_back(trans * rotate * scale);
    m_treeComponents.push_back(TreeComponents::LEAF);
}

/**
 * @brief Save current turtle state on stack.
 */
void Turtle::save() {
    m_states.push(*this);
}

/**
 * @brief End branch by restoring previous turtle state from stack.
 */
void Turtle::restore() {
    Turtle t = m_states.top();
    m_states.pop();

    m_pos = t.m_pos;
    m_thickness = t.m_thickness;
    m_dir = t.m_dir;
    m_right = t.m_right;
}

glm::mat4x4 Turtle::currTransMatrix() {
    glm::mat4x4 scale = glm::scale(glm::vec3(m_thickness, f_dist, m_thickness)); // scales cylinder in y direction by f_dist

    glm::vec3 orig = glm::vec3(0, 1, 0);
    float theta = acos(glm::dot(orig, m_dir));
    glm::mat4x4 rotate = glm::rotate(theta, glm::normalize(glm::cross(orig, m_dir)));

    glm::mat4 trans = m_sceneTrans * glm::translate(glm::vec3(m_pos.x, m_pos.y, m_pos.z)); // translates cylinder to current turtle

    if (theta == 0) { // bugs out when theta = 0, fixes issue
        return trans * scale;
    }
    return trans * rotate * scale;
}

// source: https://github.com/abiusx/L3D/blob/master/src/R3/R3Vector.cpp
glm::vec3 Turtle::rotate(glm::vec3 vec, glm::vec3 axis, float theta) {
    float cos_t = cos(theta);
    float sin_t = sin(theta);

    float dot = glm::dot(vec, axis);
    glm::vec3 cross = glm::cross(vec, axis);

    glm::vec3 res = vec * cos_t + axis * dot * (1 - cos_t) - cross * sin_t;
    return res;
}

void Turtle::yawRight(float theta) {
    glm::vec3 axis = glm::cross(m_dir, m_right);
    m_dir = glm::normalize(rotate(m_dir, axis, theta));
    m_right= glm::normalize(rotate(m_right, axis, theta));
}

void Turtle::pitchUp(float theta) {
    m_dir = glm::normalize(rotate(m_dir, m_right, theta));
}

void Turtle::rollRight(float theta) {
    m_right = glm::normalize(rotate(m_right, m_dir, theta));
}
