#include "Turtle.h"

Turtle::Turtle()
{
    m_pos = glm::vec3(0.0f, 0.0f, 0.0f);
    m_thickness = 0.2f;
    m_pitch = 0.0f;
    m_yaw = 0.0f; // initialize looking up y-axis
    m_roll = M_PI/2.0;
}

/**
 * @brief The LSystem class
 *
 * Symbolic explanations:
 * F move forward by d units
 * + yaw left by angle δ
 * - yaw right by angle δ
 * & pitch down by angle δ
 * ∧ pitch up by angle δ
 * \ roll left by angle δ
 * / roll right by angle δ
 * [ start of new branch (push the state onto the stack)
 * ] end of branch (pop the state from the stack and old state becomes current state)
 * > : decrease thickness (by percent of its own)
 * < : increase thickness (by percent of its own)
 * = : set thickness (to percentage of length)
 * * : draw leaf
 */


/**
 * @brief Iterates through string and performs actions.
 * @param input string generated by L-system.
 */
void Turtle::parseInput(std::string input) {
    m_cylinderTransformations.clear();

    std::string::size_type i = 0;
    std::string::size_type inputSize = input.size();
    while (i < inputSize) {
        char command = input[i];
        // case where command has argument
        if ((i + 3) < inputSize && input[i+1]=='(') {
            executeCommand(command, true, static_cast<float>(input[i+2]));
            i += 4;
        }
        else {
            executeCommand(command, false, 0);
            i += 1;
        }
    }
}

void Turtle::executeCommand(char command, bool hasParam, float param) {
    switch(command) {
        case 'F':
            moveForward();
            break;
        case '+':
            if (hasParam) m_yaw += param * M_PI/180.0f;
            else m_yaw += theta;
            break;
        case '-':
            if (hasParam) m_yaw -= param * M_PI/180.0f;
            else m_yaw -= theta;
            break;
        case '&':
            if (hasParam) m_pitch += param * M_PI/180.0f;
            else m_pitch += theta;
            break;
        case '^':
            if (hasParam) m_pitch -= param * M_PI/180.0f;
            else m_pitch -= theta;
            break;
        case '\\':
            if (hasParam) m_roll += param * M_PI/180.0f;
            else m_roll += theta;
            break;
        case '/':
            if (hasParam) m_roll -= param * M_PI/180.0f;
            else m_roll -= theta;
            break;
        case '[':
            this->save();
            break;
        case ']':
            this->restore();
            break;
        case '>':
            if (hasParam) m_thickness *= 1-(param/100);
            m_thickness *= 1-(thickness_mult/100);
            break;
        case '<':
            if (hasParam) m_thickness *= 1+(param/100);
            m_thickness *= 1+(thickness_mult/100);
            break;
        case '=': // TODO: not implemented yet
            m_thickness = param/100;
            break;
        case '*':
            drawLeaf();
            break;
    }
}

/**
 * @brief Draw cylinder and move turtle forward.
 */
void Turtle::moveForward() {

    // transformation matrix to current turtle position


    // calculate forward vector based on yaw, pitch, deg
    // source: https://stackoverflow.com/questions/1568568/how-to-convert-euler-angles-to-directional-vector
    float fx = cos(m_yaw) * cos(m_pitch);
    float fy = sin(m_yaw) * cos(m_pitch);
    float fz = sin(m_pitch);

    // update position vector with forward step
    m_pos = m_pos + f_dist/2 * glm::normalize(glm::vec3(fx, fy, fz)); // move forward f-dist/2

    m_cylinderTransformations.push_back(currTransMatrix());

    m_pos = m_pos + f_dist/2 * glm::normalize(glm::vec3(fx, fy, fz)); // move forward f-dist/2

    // m_pos += vec;

    //std::cout << "here" << std::endl;


    //m_cylinderTransformations.push_back(glm::mat4(1.0f));
}

/**
 * @brief Draws leaf at current turtle location.
 */
void Turtle::drawLeaf() {
    //Cylinder c(10, 10); //TODO: Find better leaf shape, transform to pos
    //c.draw();
}

/**
 * @brief Save current turtle state on stack.
 */
void Turtle::save() {
    m_states.push(*this);
}

/**
 * @brief End branch by restoring previous turtle state from stack.
 */
void Turtle::restore() {
    Turtle t = m_states.top();
    m_states.pop();

    m_pos = t.m_pos;
    m_thickness = t.m_thickness;
    m_pitch = t.m_pitch;
    m_yaw = t.m_yaw;
    m_roll = t.m_roll;
}

glm::mat4x4 Turtle::currTransMatrix() {
    glm::mat4x4 scale = glm::scale(glm::vec3(m_thickness, f_dist, m_thickness)); // scales cylinder in y direction by f_dist

    //glm::mat4x4 scale = glm::scale(glm::vec3(f_dist, m_thickness, m_thickness)); // scales cylinder in y direction by f_dist

    glm::mat4x4 yaw = glm::rotate(m_yaw, glm::vec3(0, 0, 1));
    glm::mat4x4 pitch = glm::rotate(m_pitch, glm::vec3(0, 1, 0));
    glm::mat4x4 roll = glm::rotate(m_roll, glm::vec3(1, 0, 0));
    glm::mat4x4 rotate = yaw * pitch * roll; // combines axis rotations into one rotation

//    std::cout << m_yaw << std::endl;
//    std::cout << m_pitch << std::endl;
//    std::cout << m_roll << std::endl;

    std::cout << m_pos.x << std::endl;
    std::cout << m_pos.y << std::endl;
    std::cout << m_pos.z << std::endl;

    glm::mat4 trans = glm::translate(glm::vec3(m_pos.x, m_pos.y, m_pos.z)); // translates cylinder to current turtle

    //return scale * rotate * trans;
    return trans * rotate * scale;
}
